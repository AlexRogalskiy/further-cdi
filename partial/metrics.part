[.topic.intro]
== Metrics CDI

====
Annotated Types, Interceptors, Producer Fields, Producer Methods
====


[.topic.source]
== Dropwizard Metrics

NOTE: Open-source Java library providing monitoring primitives like `Counter`, `Gauge`, `Histogram`, `Meter`, `Timer`, ...

NOTE: Provides a `MetricRegistry` that articulates modules and reporters

NOTE: Defines annotations for AOP frameworks like Spring AOP, AspectJ, Guice (AOP Alliance) *and CDI*, e.g.:

[source, subs="verbatim,quotes"]
----
class TimedMethodBean {
    [highlight]#@Timed#
    void timedMethod() {
        // Timer name => TimedMethodBean.timedMethod
    }
}
----


[.topic.source]
== Add Interceptor Bindings Programmatically

TIP: Use *Java interceptors* for Metrics annotation AOP

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {

  <X> void interceptTimedMethod(@Observes [highlight]#@WithAnnotations(Timed.class)#
    ProcessAnnotatedType<X> pat) {
    Set<AnnotatedMethod<? super X>> decoratedMethods = new HashSet<>();

    for (AnnotatedMethod<? super X> method : pat.getAnnotatedType().getMethods())
      if (method.isAnnotationPresent(Timed.class))
          decoratedMethods.add(
            new AnnotatedMethodDecorator<>(method, [highlight]#new TimedBindingLiteral()#));

    pat.setAnnotatedType(
      new AnnotatedTypeDecorator<>(pat.getAnnotatedType(), decoratedMethods));
  }
}
----


[.topic.source]
== Bean Method Interceptors

[source, subs="verbatim,quotes"]
----
[highlight]#@Interceptor#
[highlight]#@TimedBinding#
[highlight]#@Priority(Interceptor.Priority.LIBRARY_BEFORE)#
class TimedInterceptor {
    @Inject MetricRegistry registry;

    [highlight]#@AroundInvoke#
    Object timedMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try {
            return [highlight]#context.proceed()#;
        } finally {
            time.stop();
        }
    }
}
----


[.topic.source]
== The `ProcessBean<X>` Events

TIP: Use *producer fields / methods* to register custom metrics

[source, subs="verbatim,quotes"]
----
[highlight]#@Produces# Timer Timer = new Timer(new SlidingWindowReservoir(100));
----

[source]
.`ProcessProducerMethod<T, X>`
----
public interface ProcessProducerMethod<T, X> extends ProcessBean<X> {
    public AnnotatedMethod<T> getAnnotatedProducerMethod();
    public AnnotatedParameter<T> getAnnotatedDisposedParameter();
    // ProcessBean<X>
    public Annotated getAnnotated();
    public Bean<X> getBean();
}
----

NOTE: `ProcessManagedBean<X>` and `ProcessProducerField<T, X>` are fired for managed beans and producer fields respectively


[.topic.source]
== The `AfterDeploymentValidation` Event

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {
  Map<Bean<?>, AnnotatedMember<?>> metrics = new HashMap<>();
  void producerFields(@Observes [highlight]#ProcessProducerField<? extends Metric, ?># ppf) {
    metrics.put(ppf.getBean(), ppf.getAnnotatedProducerField()); <1>
  }
  void producerMethods(@Observes [highlight]#ProcessProducerMethod<? extends Metric, ?># ppm) {
    metrics.put(ppm.getBean(), ppm.getAnnotatedProducerMethod()); <1>
  }
  void customMetrics(@Observes [highlight]#AfterDeploymentValidation# adv, BeanManager manager) {
    for (Map.Entry<Bean<?>, AnnotatedMember<?>> metric : metrics.entrySet())
      registry.register(metricName(member), manager.getReference(metric.getKey(), <2>
        metric.getValue().getBaseType(), manager.createCreationalContext(null)));
  }
}
----
<1> Collect the custom `Metric` producer fields and methods
<2> Instantiate and register the custom metrics into the Metrics registry

[.topic.source]
== Complete Example

[source]
----
@Inject
private Meter hits; <1>

@Timed(name = "calls") <2>
public void cachedMethod() {
    if (hit) hits.mark();
}

@Produces @Metric(name = "cache-hits") <3>
private Gauge<Double> cacheHitRatioGauge(Meter hits, Timer calls) {
    return () -> calls.getOneMinuteRate() == 0 ? Double.NaN :
                 hits.getOneMinuteRate() / calls.getOneMinuteRate();
}
----
<1> `Metric` _injection_ from the registry
<2> Method _instrumentation_ with interceptors
<3> Produce a custom `Metric` instance by composing others
