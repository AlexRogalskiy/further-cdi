= Going _further_ with _CDI_ 1.2
Antoine Sabot-Durand; Antonin Stefanutti
:description: Going farther with CDI 1.2
:website: http://astefanutti.github.io/javaone2014
:copyright: CC BY-SA 4.0
:backend: dzslides
:sectids!:
:experimental:
:toc2:
:sectanchors:
:idprefix:
:idseparator: -
:icons: font
:source-highlighter: highlightjs
:source-language: java
:language: no-highlight
:macros-on: subs="macros"
:caption-off: caption=""
:title-off: title="", caption=""
:dzslides-aspect: 16-9
:imagesdir: images
:next-label: pass:quotes,attributes[*Next* [icon:caret-right[]]
:dzslides-style: asciidoctor
:dzslides-highlight: asciidoctor
:dzslides-transition: fade
:dzslides-fonts: family=Neuton:400,700,800,400italic|Cedarville+Cursive
:hide-uri-scheme:

[.topic.source]
== Antoine Sabot-Durand

====
* icon:user[] Senior Software Engineer
* icon:user[] CDI co-spec lead
* icon:institution[] Red Hat, Inc.
* icon:twitter[] @antoine_sd
* icon:rss[] www.next-presso.com
* icon:github[] github.com/antoinesd
====


[.topic.source]
== Antonin Stefanutti

====
* icon:user[] Software Engineer
* icon:institution[] Murex, SAS
* icon:twitter[] @astefanut
* icon:github[] github.com/astefanutti
====


[.topic.source]
== Agenda

====
* icon:info-circle[] CDI Extensions
* icon:info-circle[] Legacy Code
* icon:info-circle[] Camel CDI
* icon:info-circle[] Metrics CDI
====


[.topic.intro]
== CDI Extensions


[.topic.source]
== CDI Portable Extensions

NOTE: One of the most powerful feature of the CDI specification

NOTE: Not really popularized maybe given the high level of abstraction

NOTE: Service provider of the service `javax.enterprise.inject.spi.Extension` declared in `META-INF/services`

image::powerful.gif[role="pull-right", width="280"]


[.topic.source]
== Lifecycle Events

[plantuml, "lifecycle", "svg", height="90%"]
----
@startuml

skinparam shadowing false
skinparam activity {
  BackgroundColor Peru
  BackgroundColor<< Once >> Olive
  BorderColor White
  FontName Consolas
  FontColor White
}

(*) -right-> BeforeBeanDiscovery << Once >>

partition "Type Discovery" {
  --> ProcessAnnotatedType<T>
}

--> AfterTypeDiscovery << Once >>

partition "Bean Discovery" {
  -up-> ProcessInjectionPoint<T, X>
  --> ProcessInjectionTarget<X>
  --> ProcessBeanAttributes<T>
  --> ProcessBean<X>
  --> ProcessObserverMethod<T, X>
}

--> AfterBeanDiscovery << Once >>

-right-> AfterDeploymentValidation

-right-> (*)

@enduml
----


[.topic.intro]
== Legacy code

====
Injection points, parameterized types, programmatic bean
====


[.topic.source]
== Diagram


[.topic.intro]
== Camel CDI

====
Annotated types, events, injection Targets, transactional Observers
====


[.topic.source]
== Apache Camel

NOTE: Open-source _integration framework_ based on known Enterprise Integration Patterns

NOTE: _Bean binding and integration_ with Spring, Blueprint, Guice _and CDI_


[.topic.source]
== Camel Annotations

[source]
----
@EndpointInject(uri="jms:queue:foo")
Endpoint endpoint;

@PropertyInject(value = "timeout", defaultValue = "5000")
int timeout;

@BeanInject("foo")
FooBean foo;

@Produce(uri = "mock:foo")
ProducerTemplate producer;

@Consume(uri="jms:queue:foo")
void onFoo(@Body String body) {
    ...
}
----


[.topic.source]
== Type Discovery

[source]
.`AnnotatedType<X>`
----
public interface AnnotatedType<X> extends Annotated {
    public Class<X> getJavaClass();
    public Set<AnnotatedConstructor<X>> getConstructors();
    public Set<AnnotatedMethod<? super X>> getMethods();
    public Set<AnnotatedField<? super X>> getFields();
}
----

[source]
.`ProcessAnnotatedType<X>`
----
public interface ProcessAnnotatedType<X> {
    public AnnotatedType<X> getAnnotatedType();
    public void setAnnotatedType(AnnotatedType<X> type);
    public void veto();
}
----


[.topic.source]
== Injection Target

[source]
.`InjectionTarget<T>`
----
public interface InjectionTarget<T> extends Producer<T> {
    public void inject(T instance, CreationalContext<T> ctx);
    public void postConstruct(T instance);
    public void preDestroy(T instance);
}
----

[source]
.`ProcessInjectionTarget<T>`
----
public interface ProcessInjectionTarget<X> {
    public AnnotatedType<X> getAnnotatedType();
    public InjectionTarget<X> getInjectionTarget();
    public void setInjectionTarget(InjectionTarget<X> injectionTarget);
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Camel CDI Extension

[source]
----
class CdiCamelExtension implements Extension {
  Set<AnnotatedType<?>> camelBeans = new HashSet<>());

  void camelAnnotations(@Observes @WithAnnotations({BeanInject.class, <1>
      Consume.class, EndpointInject.class, Produce.class, PropertyInject.class})
      ProcessAnnotatedType<?> pat) {
        camelBeans.add(pat.getAnnotatedType());
  }

  <T> void camelBeansPostProcessor(@Observes ProcessInjectionTarget<T> pit) {
      if (camelBeans.contains(pit.getAnnotatedType())) <2>
        pit.setInjectionTarget(new CamelInjectionTarget<>(pit.getInjectionTarget()));
  }
}
----
<1> Detect all the types containing Camel annotations with `@WithAnnotations`
<2> Decorate these types `InjectionTarget` with a custom post-processor


[.topic.source]
== Injection Target Decoration

[source]
----
class CamelInjectionTarget<T> implements InjectionTarget<T> {
    InjectionTarget<T> delegate;
    DefaultCamelBeanPostProcessor processor;

    CamelInjectionTarget(InjectionTarget<T> target) {
        delegate = target;
        processor = new DefaultCamelBeanPostProcessor();
    }

    @Override
    public void inject(T instance, CreationalContext<T> ctx) {
        delegate.inject(instance, ctx);
        processor.postProcessBeforeInitialization(instance); <1>
    }
}
----
<1> Call the Camel default bean post-processor after CDI injection

[.topic.source]
== Camel DSL

[source]
----
from("jms:queue:{{input}}?transactionManager=#jtaTM")
  .id("Input Consumer")
  .onException().log("Rolling back message with ID ${header.JMSMessageID}")
    .rollback().id("Rollback Transaction")
    .end()
  .log("Receiving message with ID ${header.JMSMessageID}: ${body}")
  .choice()
    .when(header("JMSRedelivered").isEqualTo(Boolean.TRUE))
      .to("jms:queue:{{error}}?transactionManager=#jtaTM").id("Error Producer")
    .otherwise()
      .beanRef("transformer").id("Transformer")
      .to("murex:trade-repository").id("Trade Repository")
      .choice()
        .when(not(isInserted))
          .log("Error received: ${body}").id("Trade Repository Error")
          .throwException(new CamelExecutionException("Import Failed")))
        .otherwise()
          .log("Answer received: ${body}").id("Trade Repository Answer");
----


[.topic.source]
== Camel AOP

TIP: Camel DSL Aspect Oriented Programming with _CDI observer methods_ as pointcut and advice definitions

[source]
----
void interceptProcessor(@Observes @Before @Node("foo") Exchange exchange) {
    // intercept the exchange before processor with id "foo"
}
----

[source]
----
void interceptProcessorBody(@Observes @Node("foo") @Body String body) {
    // use Camel parameter binding annotations for the joint point context
}
----

[source]
----
void receive(@Observes(during=AFTER_SUCCESS) @Endpoint("bar") Exchange exchange) {
    // exchange sent to endpoint "bar" when the transaction is committed successfully
}
----


[.topic.source]
== Observer Method

[source]
.`ObserverMethod<T>`
----
public interface ObserverMethod<T> {
    public Class<?> getBeanClass();
    public Type getObservedType();
    public Set<Annotation> getObservedQualifiers();
    public Reception getReception();
    public TransactionPhase getTransactionPhase();
    public void notify(T event);
}
----

[source]
.`ProcessObserverMethod<T, X>`
----
public interface ProcessObserverMethod<T, X> {
    public AnnotatedMethod<X> getAnnotatedMethod();
    public ObserverMethod<T> getObserverMethod();
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Camel CDI Extension

[source]
----

----


[.topic.intro]
== Metrics CDI

====
Annotated types, alternatives, interceptors, producers
====


[.topic.source]
== Dropwizard Metrics

NOTE: Open-source Java library providing monitoring primitives like `Counter`, `Gauge`, `Histogram`, `Meter`, `timer`, ...

NOTE: Provides a `MetricRegistry` that articulates modules and reporters

NOTE: Defines annotations for AOP frameworks like Spring AOP, AspectJ, Guice (AOP Alliance) and _CDI_, e.g.:

[source]
----
class TimedMethodBean {

    @Timed
    void timedMethod() {
        // Timer name => TimedMethodBean.timedMethod
    }
}
----


[.topic.source]
== The `Bean` Interface

[source]
----
public interface Bean<T> extends Contextual<T>, BeanAttributes<T> {
    public Class<?> getBeanClass();
    public Set<InjectionPoint> getInjectionPoints();
}

public interface Contextual<T> {
    public T create(CreationalContext<T> creationalContext);
    public void destroy(T instance, CreationalContext<T> creationalContext);
}

public interface BeanAttributes<T> {
    public Set<Type> getTypes();
    public Set<Annotation> getQualifiers();
    public Class<? extends Annotation> getScope();
    public String getName();
    public Set<Class<? extends Annotation>> getStereotypes();
    public boolean isAlternative();
}
----


[.topic.source]
== Metrics CDI Extension

[source]
----
class CdiMetricsExtension implements Extension {

  void defaultMetricRegistry(@Observes AfterBeanDiscovery abd, BeanManager manager) {
    if (manager.getBeans(MetricRegistry.class, AnyLiteral.INSTANCE).isEmpty()) <1>
        abd.addBean(new MetricRegistryBean()); <2>
    }
}
----
<1> Check if there is a bean of type `MetricRegisty` enabled
<2> If any add a default `MetricRegisty` bean implementation

[source]
----
class MetricRegistryBean implements Bean<MetricRegistry> {
    @Override
    public Class<? extends Annotation> getScope() {
        return ApplicationScoped.class;
    }
}
----


[.topic.source]
== Complete Example

[source]
----
@Inject
private Meter hits; <1>

@Timed(name = "calls") <2>
public void cachedMethod() {
    if (hit) hits.mark();
}

@Produces @Metric(name = "cache-hits") <3>
private Gauge<Double> cacheHitRatioGauge(Meter hits, Timer calls) {
    return () -> calls.getOneMinuteRate() == 0 ? Double.NaN :
                 hits.getOneMinuteRate() / calls.getOneMinuteRate();
}
----
<1> `Metric` _injection_ from the registry
<2> Method _instrumentation_ with CDI interceptors
<3> Produce a custom `Metric` instance by composing others


[.topic.source]
== References

NOTE: Slides generated with _Asciidoctor_ and _DZSlides_ backend

NOTE: Original slide template - _Dan Allen_ & _Sarah White_

NOTE: Camel CDI Extension - https://github.com/astefanutti/camel-cdi

NOTE: Metrics CDI Extension - https://github.com/astefanutti/metrics-cdi


[.topic.ending, hrole="name"]
== Antoine Sabot-Durand Antonin Stefanutti

[.footer]
icon:twitter[] @antoine_sd @astefanut
