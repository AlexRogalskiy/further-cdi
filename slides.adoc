= Going _further_ with _CDI_ 1.2
Antoine Sabot-Durand; Antonin Stefanutti
:description: Going farther with CDI 1.2
:website: http://astefanutti.github.io/javaone2014
:copyright: CC BY-SA 4.0
:backend: dzslides
:sectids!:
:experimental:
:toc2:
:sectanchors:
:idprefix:
:idseparator: -
:icons: font
:source-highlighter: highlightjs
:source-language: java
:language: no-highlight
:macros-on: subs="macros"
:caption-off: caption=""
:title-off: title="", caption=""
:dzslides-aspect: 16-9
:imagesdir: images
:next-label: pass:quotes,attributes[*Next* [icon:caret-right[]]
:dzslides-style: asciidoctor
:dzslides-highlight: github
:dzslides-transition: fade
:dzslides-fonts: family=Neuton:400,700,800,400italic|Cedarville+Cursive
:hide-uri-scheme:

[.topic.source]
== Antoine Sabot-Durand

====
* icon:user[] Senior Software Engineer
* icon:user[] CDI co-spec lead
* icon:institution[] Red Hat, Inc.
* icon:twitter[] @antoine_sd
* icon:rss[] www.next-presso.com
* icon:github[] github.com/antoinesd
====


[.topic.source]
== Antonin Stefanutti

====
* icon:user[] Software Engineer
* icon:institution[] Murex, SAS
* icon:twitter[] @astefanut
* icon:github[] github.com/astefanutti
====


[.topic.source]
== Should I stay or should I go ?

====
* icon:cogs[] A talk about CDI *advanced*
====

====
* icon:reply[] Might be hard for beginners
====

====
* icon:share[] Don't need to be a CDI guru
====


[.topic.source]
== Agenda

====
* icon:info-circle[] CDI Extensions
* icon:info-circle[] Legacy Code
* icon:info-circle[] Camel CDI
* icon:info-circle[] Metrics CDI
====


[.topic.intro]
== Introducing CDI portable extensions

[.topic.source]
== CDI portable extensions

====
* Extending CDI and Java EE
* Change CDI meta data
* Link to BeanManager Lifecycle
====


[.topic.intro]
== Legacy code

====
Introduction
====


[.topic.source]
== Portable Extensions

One of the _most powerful feature_ of the CDI specification

Not really popularized partly due to the _high level of abstraction_

image::powerful.gif[role="pull-right", width="300"]


[.topic.source]
== Container Metadata

Observer pattern to listen for container _initialization lifecycle events_

Comprehensive access to and modification of the _container metadata model_

image::rubik.gif[role="pull-right", width="250"]


[.topic.source]
== Plugin Architecture

NOTE: Service provider of the service `javax.enterprise.inject.spi.Extension` declared in `META-INF/services`

[source, subs="verbatim,quotes"]
----
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.Extension;

class CdiExtension [highlight]#implements Extension# {

    void beforeBeanDiscovery([highlight]#@Observes BeforeBeanDiscovery# bbd) {
    }
    ...

    void afterDeploymentValidation([highlight]#@Observes AfterDeploymentValidation# adv) {
    }
}
----


[.topic.source]
== Lifecycle Events

[plantuml, "lifecycle", "svg", height="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  BackgroundColor #337788
  ArrowColor #888888
  BarColor #888888
  BorderColor White
  FontName Consolas
  FontColor White
  FontSize 20
}

|<size:30>**Application lifecycle**</size>|
start
#BB3322:<color:#FFFFFF>BeforeBeanDiscovery</color>>

|<size:30>**Type Discovery**</size>|

while (<size:14><color:#FFFFFF>while types in</color></size>\n<size:14><color:#FFFFFF>deployment archive?</color></size>) is (yes)
fork
    :<color:#FFFFFF>ProcessAnnotatedType<X></color>>
/' fork again
    :<color:#FFFFFF>ProcessSyntheticAnnotatedType<X></color>> '/
end fork
endwhile (no)

|<size:30>**Application lifecycle**</size>|
#BB3322:<color:#FFFFFF>AfterTypeDiscovery</color>>

|<size:30>**Bean Discovery**</size>|
fork
partition "**For each discovered types during type discovery**" {
    :<color:#FFFFFF>ProcessInjectionPoint<T, X></color>>
    :<color:#FFFFFF>ProcessInjectionTarget<X></color>>
    :<color:#FFFFFF>ProcessBeanAttributes<T></color>>
    :<color:#FFFFFF>ProcessManagedBean<X></color>>
}
fork again
partition "**For each producer methods / fields of enabled beans**" {
    :<color:#FFFFFF>ProcessInjectionPoint<T, X></color>>
    :<color:#FFFFFF>ProcessProducer<T, X></color>>
    :<color:#FFFFFF>ProcessBeanAttributes<T></color>>
    :<color:#FFFFFF>ProcessProducerMethod<T, X></color>\n<color:#FFFFFF>ProcessProducerField<T, X></color>>
}
fork again
partition "**For each observer methods of enabled beans**" {
    :<color:#FFFFFF>ProcessInjectionPoint<T, X></color>>
    :<color:#FFFFFF>ProcessObserverMethod<T, X></color>>
}
end fork

|<size:30>**Application lifecycle**</size>|
#BB3322:<color:#FFFFFF>AfterBeanDiscovery</color>>
#BB3322:<color:#FFFFFF>AfterDeploymentValidation</color>>
stop

@enduml
----


[.topic.intro]
== Legacy Code

====
Injection Points, Qualifiers Metadata, Programmatic Beans, Parameterized Types
====


[.topic.source]
== A `/\*Not So Fictional*/` Legacy Component

[plantuml, "legacy", "svg", width="100%", height="95%"]
----
@startuml
scale 600 width
scale 400 height

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam class {
  BackgroundColor #337788
  ArrowColor #888888
  BarColor #888888
  BorderColor White
  FontName Consolas
  FontColor White
  FontSize 20
  AttributeFontColor White
}

interface Executor {
    + DataDictionaryFormulaResult executeFormula(String, SDDParameterProvider)
    + byte[] executeTemplate(String, SDDParameterProvider)
    + void close()
}
note top of Executor: Transformation Engine

abstract class AbstractExecutor {
    + DataDictionaryFormulaResult executeFormula(String, SDDParameterProvider)
    + byte[] executeTemplate(String, SDDParameterProvider)
    + CacheConfig createCacheFromFile(String)
    + ManageableCache getCache(String)
    + void removeFromDictionaryCaches(Set<String>)
    + void close()
}
Executor <|.. AbstractExecutor

class OfflineExecutor {
    + OfflineExecutor(ResourceLoader, BoRepositoryService, String, String, String)
    + OfflineExecutor(ResourceLoader, BoRepositoryService, String, String, String, ClassLoader)
    __
    + void setContextClassLoader(ClassLoader)
    + setOverridenResource(Object)
}
AbstractExecutor <|-- OfflineExecutor

interface ResourceLoader {
    + Version getVersion()
    + List<DDOFormula> readFormulae()
    + List<DDOSkeleton> readSkeletons()
    + List<DDOContext> readContexts()
    + List<DDOTemplate> readTemplates()
    + DDOFormula readFormula(String)
    + DDOSkeleton readSkeleton(String)
    + DDOContext readContext(String)
    + DDOTemplate readTemplate(String)
    + DDOTemplate readTemplate(String, String)
    + boolean isFormulaExists(String)
    + int getType()
    + String getLocation()
    + void cleanUp()
    + byte[] getClazz(String)
    + byte[] getJavaClass(String)
}
note top of ResourceLoader: Transformation Configuration / Logic
OfflineExecutor -left-> ResourceLoader

class SDDParameterProvider {
    + String getExtractionFormula()
    + void setExtractionFormula(String)
    + boolean isEmpty()
    + SDDParameterProvider clone()
    + setMxObject(Object)
    + updateWithXmlEntry(XmlEntry)
    + Set<String> getContexts()
    + Map<String, Object> getFields()
}
note top of SDDParameterProvider: Transformation Input Model
Executor -left- SDDParameterProvider : input >

abstract Class AbstractParameterProvider {
    + Map<String, Object> getFields()
    + Map<String, Object> getParameters()
    + TraceableDocument getDocument(String)
    + Object getField(String)
    + Object getParameter(String)
    + String getLocalParameter(String)
    + String getGlobalParameter(String)
    + Map<String, TraceableDocument> getDocuments()
    + Object getBO()
    + Serializable getKey(String)
}
SDDParameterProvider -down-|> AbstractParameterProvider

class DataDictionaryFormulaResult {
    + String getFormulaReturnTypeAsString(int)
    + int getFormulaReturnTypeAsInt(int)
    + void cleanUp()
    + void createObject(int, int)
    + int getLineCount()
    + int getColumnCount()
    + Object getObjectValue(int, int)
    + String getValue(int, int)
    + void createObject(Element)
    + void createObject(SAXSerializable)
    + void createObject(DataDictionaryFormulaResultCell[][])
    + void setColumnTitles(String [])
    + boolean isTreeResult()
    + boolean isObjectResult()
    + void setValueAt(int, int, DataDictionaryFormulaResultCell[][])
    + void setColumnTitleAt(int, String)
    + Object[][] getObjectResult()
}
note top of DataDictionaryFormulaResult: Transformation Output Model / Type Conversion
Executor -- DataDictionaryFormulaResult : output >

@enduml
----


[.topic.source]
== The CDI Way

TIP: A functional interface:

[source]
----
public interface Transformer<I, O> {
    O transform(I input);
}
----

TIP: And a CDI qualifier with transformation metadata:

[source, subs="verbatim,quotes"]
----
import javax.enterprise.util.Nonbinding;
import javax.inject.Qualifier;
[highlight]#@Qualifier#
public @interface Transformation {
    [highlight]#@Nonbinding#
    String value() default ""; // The transformation name
}
----


[.topic.source]
== Configuration at Injection Points

[source, subs="verbatim,quotes"]
----
@Inject [highlight]#@Transformation("transformation")#
Transformer<InputType, OutputType> transformer;

InputType input;
OutputType result = transformer.transform(input);
----

TIP: Distribute configuration closest to the code:

[source, subs="verbatim,quotes"]
----
@Inject
[highlight]#@Transformation("transformation~i~")#
Transformer<InputType~i~, OutputType~i~> transformer~i~;
...
@Inject
[highlight]#@Transformation("transformation~j~")#
Transformer<InputType~j~, OutputType~j~> transformer~j~;
----


[.topic.source]
== The `ProcessInjectionPoint` Event

TIP: Collect all the `@Transformation` metadata required to instantiate the legacy component

[source]
.`ProcessInjectionPoint<T, X>`
----
public interface ProcessInjectionPoint<T, X> {
    public InjectionPoint getInjectionPoint();
    public void setInjectionPoint(InjectionPoint injectionPoint);
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Collect Injection Points Metadata

[source, subs="verbatim,quotes"]
----
class TransformationExtension implements Extension {

  Set<String> transformations = new HashSet<>();

  void collectConfiguration(@Observes [highlight]#ProcessInjectionPoint<?, Transformer># pit) { <1>
    Annotated annotated = pit.getInjectionPoint().getAnnotated();
    if (annotated.isAnnotationPresent(Transformation.class)) {
      transformations.add(annotated.getAnnotation(Transformation.class).value()); <2>
    }
  }
}
----
<1> Observe every injection point of type `Transformer` on any declaring bean
<2> Collect the injection point `@Transformation` metadata


[.topic.source]
== The `Bean` Interface

TIP: Integrate the legacy component as a CDI Bean

[source]
----
public interface Bean<T> extends Contextual<T>, BeanAttributes<T> {
    public Class<?> getBeanClass();
    public Set<InjectionPoint> getInjectionPoints();
    // Contextual<T>
    public T create(CreationalContext<T> creationalContext);
    public void destroy(T instance, CreationalContext<T> creationalContext);
    // BeanAttributes<T>
    public Set<Type> getTypes();
    public Set<Annotation> getQualifiers();
    public Class<? extends Annotation> getScope();
    public String getName();
    public Set<Class<? extends Annotation>> getStereotypes();
    public boolean isAlternative();
}
----


[.topic.source]
== Define Beans Programmatically

[source, subs="verbatim,quotes"]
----
class LegacyTransformerBean [highlight]#implements Bean<LegacyTransformer># {
    Set<String> transformations = new HashSet<>();
    LegacyTransformerBean(Set<String> transformations) {
        this.transformations = transformations;
    }
    public LegacyTransformer create(CreationalContext<LegacyTransformer> context) {
        LegacyTransformer transformer = [highlight]#new LegacyTransformer()#;
        tranformer.load(transformations);
        return LegacyTransformer;
    }
    public Set<Annotation> getQualifiers() {
        return Collections.unmodifiableSet(new HashSet<>(
            Arrays.asList([highlight]#DefaultLiteral.INSTANCE#, [highlight]#AnyLiteral.INSTANCE#)));
    }
    public Class<? extends Annotation> getScope() {
        return [highlight]#ApplicationScoped.class#;
    }
}
----


[.topic.source]
== The `AfterBeanDiscovery` Event

TIP: Add the legacy component bean after bean discovery

[source]
.`AfterBeanDiscovery`
----
public interface AfterBeanDiscovery {
    public void addDefinitionError(Throwable t);
    public void addBean(Bean<?> bean);
    public void addObserverMethod(ObserverMethod<?> observerMethod);
    public void addContext(Context context);
    public <T> AnnotatedType<T> getAnnotatedType(Class<T> type, String id);
    public <T> Iterable<AnnotatedType<T>> getAnnotatedTypes(Class<T> type);
}
----


[.topic.source]
== Add Beans Programmatically

[source, subs="verbatim,quotes"]
----
class TransformationExtension implements Extension {

  Set<String> transformations = new HashSet<>();

  void collectConfiguration(@Observes ProcessInjectionPoint<?, Transformer> pit) {
    Annotated annotated = pit.getInjectionPoint().getAnnotated();
    if (annotated.isAnnotationPresent(Transformation.class))
      transformations.add(annotated.getAnnotation(Transformation.class).value());
  }
  void addLegacyTransformerBean(@Observes [highlight]#AfterBeanDiscovery# abd) {
    LegacyTransformer legacyTransformer = new LegacyTransformer(transformations);
    abd.[highlight]#addBean(new LegacyTransformerBean>(transformations))#;
  }
}
----


[.topic.source]
== Generics as Metadata

TIP: *Parameterized types are not erased by CDI* so that they can be used as metadata, for example for type conversion:

[source, subs="verbatim,quotes"]
----
@Produces
@Transformation
[highlight]#<I, O> Transformer<I, O># legacyTransformerFacade(*LegacyTransformer legacyTransformer*,
  InjectionPoint injectionPoint) {
  Transformation transformation = getQualifierByType(injectionPoint.getQualifiers(),
                                                     Transformation.class);

  return new LegacyTransformerFacade<I, O>(legacyTransformer, transformation.value(),
    [highlight]#injectionPoint.getType()#));
}
----


[.topic.intro]
== Camel CDI

====
Annotated Types, Injection Targets, Observer Methods
====


[.topic.source]
== Apache Camel

NOTE: Open-source _integration framework_ based on known Enterprise Integration Patterns

NOTE: _Bean binding and integration_ with Spring, Blueprint, Guice *and CDI*

image::eip.gif[height="150"]


[.topic.source]
== Camel Annotations

[source, subs="verbatim,quotes"]
----
[highlight]#@EndpointInject#(uri="jms:queue:foo")
Endpoint endpoint;

[highlight]#@PropertyInject#(value = "timeout", defaultValue = "5000")
int timeout;

[highlight]#@BeanInject#("foo")
FooBean foo;

[highlight]#@Produce#(uri = "mock:foo")
ProducerTemplate producer;

[highlight]#@Consume#(uri="jms:queue:foo")
void onFoo(@Body String body) {
}
----
TIP: Bring support for both Camel and CDI beans...

[.topic.source]
== The `ProcessAnnotatedType` Event

[source]
.`AnnotatedType<X>`
----
public interface AnnotatedType<X> extends Annotated {
    public Class<X> getJavaClass();
    public Set<AnnotatedConstructor<X>> getConstructors();
    public Set<AnnotatedMethod<? super X>> getMethods();
    public Set<AnnotatedField<? super X>> getFields();
}
----

[source]
.`ProcessAnnotatedType<X>`
----
public interface ProcessAnnotatedType<X> {
    public AnnotatedType<X> getAnnotatedType();
    public void setAnnotatedType(AnnotatedType<X> type);
    public void veto();
}
----


[.topic.source]
== The `ProcessInjectionTarget` Event

[source]
.`InjectionTarget<T>`
----
public interface InjectionTarget<T> extends Producer<T> {
    public void inject(T instance, CreationalContext<T> ctx);
    public void postConstruct(T instance);
    public void preDestroy(T instance);
}
----

[source]
.`ProcessInjectionTarget<T>`
----
public interface ProcessInjectionTarget<X> {
    public AnnotatedType<X> getAnnotatedType();
    public InjectionTarget<X> getInjectionTarget();
    public void setInjectionTarget(InjectionTarget<X> injectionTarget);
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Bean Post Processors

[source, subs="verbatim,quotes"]
----
class CdiCamelExtension implements Extension {
  Set<AnnotatedType<?>> camelBeans = new HashSet<>());

  void camelAnnotations(@Observes [highlight]#@WithAnnotations({BeanInject.class, <1>
      Consume.class, EndpointInject.class, Produce.class, PropertyInject.class})#
      ProcessAnnotatedType<?> pat) {
        camelBeans.add(pat.getAnnotatedType());
  }

  <T> void camelBeansPostProcessor(@Observes [highlight]#ProcessInjectionTarget<T># pit) {
      if (camelBeans.contains(pit.getAnnotatedType())) <2>
        pit.setInjectionTarget(new CamelInjectionTarget<>(pit.getInjectionTarget()));
  }
}
----
<1> Detect all the types containing Camel annotations with `@WithAnnotations`
<2> Decorate the `InjectionTarget` corresponding to these types with a custom post-processor


[.topic.source]
== `InjectionTarget` Decoration

[source, subs="verbatim,quotes"]
----
class CamelInjectionTarget<T> [highlight]#implements InjectionTarget<T># {
    InjectionTarget<T> delegate;

    DefaultCamelBeanPostProcessor processor;

    CamelInjectionTarget(InjectionTarget<T> target) {
        delegate = target;
        processor = new DefaultCamelBeanPostProcessor();
    }
    @Override
    public void [highlight]#inject#(T instance, CreationalContext<T> ctx) {
        delegate.inject(instance, ctx);
        [highlight]#processor.postProcessBeforeInitialization(instance)#; <1>
    }
}
----
<1> Call the Camel default bean post-processor after CDI injection

[.topic.source]
== Camel DSL

[source]
----
from("jms:queue:{{input}}?transactionManager=#jtaTM")
  .id("Input Consumer")
  .onException().log("Rolling back message with ID ${header.JMSMessageID}")
    .rollback().id("Rollback Transaction")
    .end()
  .log("Receiving message with ID ${header.JMSMessageID}: ${body}")
  .choice()
    .when(header("JMSRedelivered").isEqualTo(Boolean.TRUE))
      .to("jms:queue:{{error}}?transactionManager=#jtaTM").id("Error Producer")
    .otherwise()
      .beanRef("transformer").id("Transformer")
      .to("murex:trade-repository").id("Trade Repository")
      .choice()
        .when(not(isInserted))
          .log("Error received: ${body}").id("Trade Repository Error")
          .throwException(new CamelExecutionException("Import Failed")))
        .otherwise()
          .log("Answer received: ${body}").id("Trade Repository Answer");
----


[.topic.source]
== Camel AOP

TIP: Camel DSL Aspect Oriented Programming with node IDs and endpoint URLs as joinpoints and *CDI observer methods as pointcut and advice definitions*

[source, subs="verbatim,quotes"]
----
void interceptProcessor(@Observes [highlight]#@Before @Node("foo")# Exchange exchange) {
    // intercept the exchange before processor with id "foo"
}
----

[source, subs="verbatim,quotes"]
----
void interceptProcessorBody(@Observes @Node("foo") [highlight]#@Body String body#) {
    // use Camel parameter binding annotations for the joint point context
}
----

[source, subs="verbatim,quotes"]
----
void receive(@Observes([highlight]#during=AFTER_SUCCESS) @Endpoint("bar")# Exchange exchange) {
    // exchange sent to endpoint "bar" when the transaction is committed successfully
}
----


[.topic.source]
== The `ProcessObserverMethod` Event

[source]
.`ObserverMethod<T>`
----
public interface ObserverMethod<T> {
    public Class<?> getBeanClass();
    public Type getObservedType();
    public Set<Annotation> getObservedQualifiers();
    public Reception getReception();
    public TransactionPhase getTransactionPhase();
    public void notify(T event);
}
----

[source]
.`ProcessObserverMethod<T, X>`
----
public interface ProcessObserverMethod<T, X> {
    public AnnotatedMethod<X> getAnnotatedMethod();
    public ObserverMethod<T> getObserverMethod();
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Camel CDI Extension

[source]
----

----


[.topic.intro]
== Metrics CDI

====
Annotated Types, Interceptors, Producer Fields, Producer Methods
====


[.topic.source]
== Dropwizard Metrics

NOTE: Open-source Java library providing monitoring primitives like `Counter`, `Gauge`, `Histogram`, `Meter`, `Timer`, ...

NOTE: Provides a `MetricRegistry` that articulates modules and reporters

NOTE: Defines annotations for AOP frameworks like Spring AOP, AspectJ, Guice (AOP Alliance) *and CDI*, e.g.:

[source, subs="verbatim,quotes"]
----
class TimedMethodBean {
    [highlight]#@Timed#
    void timedMethod() {
        // Timer name => TimedMethodBean.timedMethod
    }
}
----


[.topic.source]
== Add Interceptor Bindings Programmatically

TIP: Use *Java interceptors* for Metrics annotation AOP

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {

  <X> void interceptTimedMethod(@Observes [highlight]#@WithAnnotations(Timed.class)#
    ProcessAnnotatedType<X> pat) {
    Set<AnnotatedMethod<? super X>> decoratedMethods = new HashSet<>();

    for (AnnotatedMethod<? super X> method : pat.getAnnotatedType().getMethods())
      if (method.isAnnotationPresent(Timed.class))
          decoratedMethods.add(
            new AnnotatedMethodDecorator<>(method, [highlight]#new TimedBindingLiteral()#));

    pat.setAnnotatedType(
      new AnnotatedTypeDecorator<>(pat.getAnnotatedType(), decoratedMethods));
  }
}
----


[.topic.source]
== Bean Method Interceptors

[source, subs="verbatim,quotes"]
----
[highlight]#@Interceptor#
[highlight]#@TimedBinding#
[highlight]#@Priority(Interceptor.Priority.LIBRARY_BEFORE)#
class TimedInterceptor {
    @Inject MetricRegistry registry;

    [highlight]#@AroundInvoke#
    Object timedMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try {
            return [highlight]#context.proceed()#;
        } finally {
            time.stop();
        }
    }
}
----


[.topic.source]
== The `ProcessBean<X>` Events

TIP: Use *producer fields / methods* to register custom metrics

[source, subs="verbatim,quotes"]
----
[highlight]#@Produces# Timer Timer = new Timer(new SlidingWindowReservoir(100));
----

[source]
.`ProcessProducerMethod<T, X>`
----
public interface ProcessProducerMethod<T, X> extends ProcessBean<X> {
    public AnnotatedMethod<T> getAnnotatedProducerMethod();
    public AnnotatedParameter<T> getAnnotatedDisposedParameter();
    // ProcessBean<X>
    public Annotated getAnnotated();
    public Bean<X> getBean();
}
----

NOTE: `ProcessManagedBean<X>` and `ProcessProducerField<T, X>` are fired for managed beans and producer fields respectively


[.topic.source]
== The `AfterDeploymentValidation` Event

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {
  Map<Bean<?>, AnnotatedMember<?>> metrics = new HashMap<>();
  void producerFields(@Observes [highlight]#ProcessProducerField<? extends Metric, ?># ppf) {
    metrics.put(ppf.getBean(), ppf.getAnnotatedProducerField()); <1>
  }
  void producerMethods(@Observes [highlight]#ProcessProducerMethod<? extends Metric, ?># ppm) {
    metrics.put(ppm.getBean(), ppm.getAnnotatedProducerMethod()); <1>
  }
  void customMetrics(@Observes [highlight]#AfterDeploymentValidation# adv, BeanManager manager) {
    for (Map.Entry<Bean<?>, AnnotatedMember<?>> metric : metrics.entrySet())
      registry.register(metricName(member), manager.getReference(metric.getKey(), <2>
        metric.getValue().getBaseType(), manager.createCreationalContext(null)));
  }
}
----
<1> Collect the custom `Metric` producer fields and methods
<2> Instantiate and register the custom metrics into the Metrics registry

[.topic.source]
== Complete Example

[source]
----
@Inject
private Meter hits; <1>

@Timed(name = "calls") <2>
public void cachedMethod() {
    if (hit) hits.mark();
}

@Produces @Metric(name = "cache-hits") <3>
private Gauge<Double> cacheHitRatioGauge(Meter hits, Timer calls) {
    return () -> calls.getOneMinuteRate() == 0 ? Double.NaN :
                 hits.getOneMinuteRate() / calls.getOneMinuteRate();
}
----
<1> `Metric` _injection_ from the registry
<2> Method _instrumentation_ with interceptors
<3> Produce a custom `Metric` instance by composing others


[.topic.source]
== References

NOTE: Slides generated with _Asciidoctor_, _PlantUML_ and _DZSlides_ backend

NOTE: Original slide template - _Dan Allen_ & _Sarah White_

NOTE: Camel CDI Extension - https://github.com/astefanutti/camel-cdi

NOTE: Metrics CDI Extension - https://github.com/astefanutti/metrics-cdi


[.topic.ending, hrole="name"]
== Antoine Sabot-Durand Antonin Stefanutti

[.footer]
icon:twitter[] @antoine_sd @astefanut
