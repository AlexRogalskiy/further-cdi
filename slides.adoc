= Going _further_ with _CDI_ 1.2
Antoine Sabot-Durand; Antonin Stefanutti
:description: Going farther with CDI 1.2
:website: http://astefanutti.github.io/javaone2014
:copyright: CC BY-SA 4.0
:backend: dzslides
:sectids!:
:experimental:
:toc2:
:sectanchors:
:idprefix:
:idseparator: -
:icons: font
:source-highlighter: highlightjs
:source-language: java
:language: no-highlight
:macros-on: subs="macros"
:caption-off: caption=""
:title-off: title="", caption=""
:dzslides-aspect: 16-9
:imagesdir: images
:next-label: pass:quotes,attributes[*Next* [icon:caret-right[]]
:dzslides-style: asciidoctor
:dzslides-highlight: asciidoctor
:dzslides-transition: fade
:dzslides-fonts: family=Neuton:400,700,800,400italic|Cedarville+Cursive
:hide-uri-scheme:

[.topic.source]
== Antoine Sabot-Durand

====
* icon:user[] Senior Software Engineer
* icon:user[] CDI co-spec lead
* icon:institution[] Red Hat, Inc.
* icon:twitter[] @antoine_sd
* icon:rss[] www.next-presso.com
* icon:github[] github.com/antoinesd
====


[.topic.source]
== Antonin Stefanutti

====
* icon:user[] Software Engineer
* icon:institution[] Murex, SAS
* icon:twitter[] @astefanut
* icon:github[] github.com/astefanutti
====


[.topic.source]
== Agenda

====
* icon:info-circle[] CDI Extensions
* icon:info-circle[] Legacy Code
* icon:info-circle[] Camel CDI
* icon:info-circle[] Metrics CDI
====


[.topic.intro]
== CDI Extensions


[.topic.source]
== Portable Extensions

One of the _most powerful feature_ of the CDI specification

Not really popularized maybe given the _high level of abstraction_

image::powerful.gif[role="pull-right", width="300"]


[.topic.source]
== Container Metadata

Observer pattern to listen for container _initialization lifecycle events_

Comprehensive access to and modification of the _container metadata model_

image::rubik.gif[role="pull-right", width="250"]


[.topic.source]
== Plugin Architecture

NOTE: Service provider of the service `javax.enterprise.inject.spi.Extension` declared in `META-INF/services`

[source]
----
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.Extension;

class CdiExtension implements Extension {

    void beforeBeanDiscovery(@Observes BeforeBeanDiscovery bbd) {
    }
    ...

    void afterDeploymentValidation(@Observes AfterDeploymentValidation adv) {
    }
}
----


[.topic.source]
== Lifecycle Events

[plantuml, "lifecycle", "svg", height="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  BackgroundColor #337788
  ArrowColor #888888
  BarColor #888888
  BorderColor White
  FontName Consolas
  FontColor White
  FontSize 20
}

|<size:30>**Application lifecycle**</size>|
start
#BB3322:<color:#FFFFFF>BeforeBeanDiscovery</color>>

|<size:30>**Type Discovery**</size>|

while (<size:14><color:#FFFFFF>while types in</color></size>\n<size:14><color:#FFFFFF>deployment archive?</color></size>) is (yes)
fork
    :<color:#FFFFFF>ProcessAnnotatedType<X></color>>
/' fork again
    :<color:#FFFFFF>ProcessSyntheticAnnotatedType<X></color>> '/
end fork
endwhile (no)

|<size:30>**Application lifecycle**</size>|
#BB3322:<color:#FFFFFF>AfterTypeDiscovery</color>>

|<size:30>**Bean Discovery**</size>|
fork
partition "**For each discovered types during type discovery**" {
    :<color:#FFFFFF>ProcessInjectionPoint<T, X></color>>
    :<color:#FFFFFF>ProcessInjectionTarget<X></color>>
    :<color:#FFFFFF>ProcessBeanAttributes<T></color>>
    :<color:#FFFFFF>ProcessManagedBean<X></color>>
}
fork again
partition "**For each producer methods / fields of enabled beans**" {
    :<color:#FFFFFF>ProcessInjectionPoint<T, X></color>>
    :<color:#FFFFFF>ProcessProducer<T, X></color>>
    :<color:#FFFFFF>ProcessBeanAttributes<T></color>>
    :<color:#FFFFFF>ProcessProducerMethod<T, X></color>\n<color:#FFFFFF>ProcessProducerField<T, X></color>>
}
fork again
partition "**For each observer methods of enabled beans**" {
    :<color:#FFFFFF>ProcessInjectionPoint<T, X></color>>
    :<color:#FFFFFF>ProcessObserverMethod<T, X></color>>
}
end fork

|<size:30>**Application lifecycle**</size>|
#BB3322:<color:#FFFFFF>AfterBeanDiscovery</color>>
#BB3322:<color:#FFFFFF>AfterDeploymentValidation</color>>
stop

@enduml
----


[.topic.intro]
== Legacy code

====
Injection points, parameterized types, programmatic bean
====


[.topic.source]
== Diagram


[.topic.intro]
== Camel CDI

====
Annotated types, events, injection Targets, transactional Observers
====


[.topic.source]
== Apache Camel

NOTE: Open-source _integration framework_ based on known Enterprise Integration Patterns

NOTE: _Bean binding and integration_ with Spring, Blueprint, Guice _and CDI_

image::eip.gif[height="150"]


[.topic.source]
== Camel Annotations

[source]
----
@EndpointInject(uri="jms:queue:foo")
Endpoint endpoint;

@PropertyInject(value = "timeout", defaultValue = "5000")
int timeout;

@BeanInject("foo")
FooBean foo;

@Produce(uri = "mock:foo")
ProducerTemplate producer;

@Consume(uri="jms:queue:foo")
void onFoo(@Body String body) {
}
----
TIP: Bring support for both Camel and CDI beans...

[.topic.source]
== The `ProcessAnnotatedType` Event

[source]
.`AnnotatedType<X>`
----
public interface AnnotatedType<X> extends Annotated {
    public Class<X> getJavaClass();
    public Set<AnnotatedConstructor<X>> getConstructors();
    public Set<AnnotatedMethod<? super X>> getMethods();
    public Set<AnnotatedField<? super X>> getFields();
}
----

[source]
.`ProcessAnnotatedType<X>`
----
public interface ProcessAnnotatedType<X> {
    public AnnotatedType<X> getAnnotatedType();
    public void setAnnotatedType(AnnotatedType<X> type);
    public void veto();
}
----


[.topic.source]
== The `ProcessInjectionTarget` Event

[source]
.`InjectionTarget<T>`
----
public interface InjectionTarget<T> extends Producer<T> {
    public void inject(T instance, CreationalContext<T> ctx);
    public void postConstruct(T instance);
    public void preDestroy(T instance);
}
----

[source]
.`ProcessInjectionTarget<T>`
----
public interface ProcessInjectionTarget<X> {
    public AnnotatedType<X> getAnnotatedType();
    public InjectionTarget<X> getInjectionTarget();
    public void setInjectionTarget(InjectionTarget<X> injectionTarget);
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Bean Post Processors

[source]
----
class CdiCamelExtension implements Extension {
  Set<AnnotatedType<?>> camelBeans = new HashSet<>());

  void camelAnnotations(@Observes @WithAnnotations({BeanInject.class, <1>
      Consume.class, EndpointInject.class, Produce.class, PropertyInject.class})
      ProcessAnnotatedType<?> pat) {
        camelBeans.add(pat.getAnnotatedType());
  }

  <T> void camelBeansPostProcessor(@Observes ProcessInjectionTarget<T> pit) {
      if (camelBeans.contains(pit.getAnnotatedType())) <2>
        pit.setInjectionTarget(new CamelInjectionTarget<>(pit.getInjectionTarget()));
  }
}
----
<1> Detect all the types containing Camel annotations with `@WithAnnotations`
<2> Decorate the `InjectionTarget` corresponding to these types with a custom post-processor


[.topic.source]
== `InjectionTarget` Decoration

[source]
----
class CamelInjectionTarget<T> implements InjectionTarget<T> {
    InjectionTarget<T> delegate;
    DefaultCamelBeanPostProcessor processor;

    CamelInjectionTarget(InjectionTarget<T> target) {
        delegate = target;
        processor = new DefaultCamelBeanPostProcessor();
    }

    @Override
    public void inject(T instance, CreationalContext<T> ctx) {
        delegate.inject(instance, ctx);
        processor.postProcessBeforeInitialization(instance); <1>
    }
}
----
<1> Call the Camel default bean post-processor after CDI injection

[.topic.source]
== Camel DSL

[source]
----
from("jms:queue:{{input}}?transactionManager=#jtaTM")
  .id("Input Consumer")
  .onException().log("Rolling back message with ID ${header.JMSMessageID}")
    .rollback().id("Rollback Transaction")
    .end()
  .log("Receiving message with ID ${header.JMSMessageID}: ${body}")
  .choice()
    .when(header("JMSRedelivered").isEqualTo(Boolean.TRUE))
      .to("jms:queue:{{error}}?transactionManager=#jtaTM").id("Error Producer")
    .otherwise()
      .beanRef("transformer").id("Transformer")
      .to("murex:trade-repository").id("Trade Repository")
      .choice()
        .when(not(isInserted))
          .log("Error received: ${body}").id("Trade Repository Error")
          .throwException(new CamelExecutionException("Import Failed")))
        .otherwise()
          .log("Answer received: ${body}").id("Trade Repository Answer");
----


[.topic.source]
== Camel AOP

TIP: Camel DSL Aspect Oriented Programming with _CDI observer methods_ as pointcut and advice definitions

[source]
----
void interceptProcessor(@Observes @Before @Node("foo") Exchange exchange) {
    // intercept the exchange before processor with id "foo"
}
----

[source]
----
void interceptProcessorBody(@Observes @Node("foo") @Body String body) {
    // use Camel parameter binding annotations for the joint point context
}
----

[source]
----
void receive(@Observes(during=AFTER_SUCCESS) @Endpoint("bar") Exchange exchange) {
    // exchange sent to endpoint "bar" when the transaction is committed successfully
}
----


[.topic.source]
== The `ProcessObserverMethod` Event

[source]
.`ObserverMethod<T>`
----
public interface ObserverMethod<T> {
    public Class<?> getBeanClass();
    public Type getObservedType();
    public Set<Annotation> getObservedQualifiers();
    public Reception getReception();
    public TransactionPhase getTransactionPhase();
    public void notify(T event);
}
----

[source]
.`ProcessObserverMethod<T, X>`
----
public interface ProcessObserverMethod<T, X> {
    public AnnotatedMethod<X> getAnnotatedMethod();
    public ObserverMethod<T> getObserverMethod();
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Camel CDI Extension

[source]
----

----


[.topic.intro]
== Metrics CDI

====
Annotated types, alternatives, interceptors, producers
====


[.topic.source]
== Dropwizard Metrics

NOTE: Open-source Java library providing monitoring primitives like `Counter`, `Gauge`, `Histogram`, `Meter`, `Timer`, ...

NOTE: Provides a `MetricRegistry` that articulates modules and reporters

NOTE: Defines annotations for AOP frameworks like Spring AOP, AspectJ, Guice (AOP Alliance) and _CDI_, e.g.:

[source]
----
class TimedMethodBean {

    @Timed
    void timedMethod() {
        // Timer name => TimedMethodBean.timedMethod
    }
}
----


[.topic.source]
== The `Bean` Interface

TIP: Integrate the `MetricRegistry` as a CDI Bean

[source]
----
public interface Bean<T> extends Contextual<T>, BeanAttributes<T> {
    public Class<?> getBeanClass();
    public Set<InjectionPoint> getInjectionPoints();
    // Contextual<T>
    public T create(CreationalContext<T> creationalContext);
    public void destroy(T instance, CreationalContext<T> creationalContext);
    // BeanAttributes<T>
    public Set<Type> getTypes();
    public Set<Annotation> getQualifiers();
    public Class<? extends Annotation> getScope();
    public String getName();
    public Set<Class<? extends Annotation>> getStereotypes();
    public boolean isAlternative();
}
----


[.topic.source]
== The `MetricRegistry` Bean

[source]
----
class MetricRegistryBean implements Bean<MetricRegistry> {

    public Set<Annotation> getQualifiers() {
        return Collections.unmodifiableSet(new HashSet<>(
            Arrays.asList(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE)));
    }

    public MetricRegistry create(CreationalContext<MetricRegistry> context) {
        return new MetricRegistry();
    }

    public Class<? extends Annotation> getScope() {
        return ApplicationScoped.class;
    }
    ...
}
----


[.topic.source]
== The `AfterBeanDiscovery` Event

TIP: Add the default `MetricRegistry` bean after bean discovery

[source]
----
public interface AfterBeanDiscovery {
    public void addDefinitionError(Throwable t);
    public void addBean(Bean<?> bean);
    public void addObserverMethod(ObserverMethod<?> observerMethod);
    public void addContext(Context context);
    public <T> AnnotatedType<T> getAnnotatedType(Class<T> type, String id);
    public <T> Iterable<AnnotatedType<T>> getAnnotatedTypes(Class<T> type);
}
----


[.topic.source]
== Add Beans Programmatically

[source]
----
class CdiMetricsExtension implements Extension {
  void defaultMetricRegistry(@Observes AfterBeanDiscovery abd, BeanManager manager) {
    if (manager.getBeans(MetricRegistry.class, AnyLiteral.INSTANCE).isEmpty()) <1>
        abd.addBean(new MetricRegistryBean()); <2>
    }
}
----
<1> Check if there is a bean of type `MetricRegisty` enabled
<2> If any add a default `MetricRegisty` bean implementation

NOTE: Else, the end-user deployed `MetricRegistry` bean is used, e.g.:

[source]
----
@Produces
@ApplicationScoped
MetricRegistry customMetricRegistry() {
}
----


[.topic.source]
== Add Interceptor Bindings Programmatically

TIP: Use interceptors for Metrics annotation AOP

[source]
----
class MetricsExtension implements Extension {

  <X> void interceptTimedMethod(@Observes @WithAnnotations(Timed.class)
    ProcessAnnotatedType<X> pat) {
    Set<AnnotatedMethod<? super X>> decoratedMethods = new HashSet<>();
    for (AnnotatedMethod<? super X> method : pat.getAnnotatedType().getMethods()) {
      if (method.isAnnotationPresent(Timed.class)) {
          decoratedMethods.add(
            new AnnotatedMethodDecorator<>(method, new TimedBindingLiteral()));
      }
    }
    pat.setAnnotatedType(
      new AnnotatedTypeDecorator<>(pat.getAnnotatedType(), decoratedMethods));
  }
}
----


[.topic.source]
== Bean Method Interceptors

[source]
----
@Interceptor
@TimedBinding
@Priority(Interceptor.Priority.LIBRARY_BEFORE)
class TimedInterceptor {

    @Inject MetricRegistry registry;

    @AroundInvoke
    Object timedMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try {
            return context.proceed();
        } finally {
            time.stop();
        }
    }
}
----


[.topic.source]
== The `ProcessBean<X>` Events

TIP: Use producer fields / methods to register custom metrics

[source]
----
@Produces
Timer Timer = new Timer(new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));
----

[source]
.`ProcessProducerMethod<T, X>`
----
public interface ProcessProducerMethod<T, X> extends ProcessBean<X> {
    public AnnotatedMethod<T> getAnnotatedProducerMethod();
    public AnnotatedParameter<T> getAnnotatedDisposedParameter();
    // ProcessBean<X>
    public Annotated getAnnotated();
    public Bean<X> getBean();
}
----

NOTE: `ProcessManagedBean<X>` and `ProcessProducerField<T, X>` are fired for managed beans and producer fields respectively


[.topic.source]
== The `AfterDeploymentValidation` Event

[source]
----
class MetricsExtension implements Extension {
  Map<Bean<?>, AnnotatedMember<?>> metrics = new HashMap<>();

  void producerFields(@Observes ProcessProducerField<? extends Metric, ?> ppf) {
      metrics.put(ppf.getBean(), ppf.getAnnotatedProducerField()); <1>
  }
  void producerMethods(@Observes ProcessProducerMethod<? extends Metric, ?> ppm) {
      metrics.put(ppm.getBean(), ppm.getAnnotatedProducerMethod()); <1>
  }
  void customMetrics(@Observes AfterDeploymentValidation adv, BeanManager manager) {
      for (Map.Entry<Bean<?>, AnnotatedMember<?>> metric : metrics.entrySet())
        registry.register(metricName(member), manager.getReference(metric.getKey(), <2>
            metric.getValue().getBaseType(), manager.createCreationalContext(null)));
  }
}
----
<1> Collect the custom `Metric` producer fields and methods
<2> Instantiate the custom metrics into the Metrics registry

[.topic.source]
== Complete Example

[source]
----
@Inject
private Meter hits; <1>

@Timed(name = "calls") <2>
public void cachedMethod() {
    if (hit) hits.mark();
}

@Produces @Metric(name = "cache-hits") <3>
private Gauge<Double> cacheHitRatioGauge(Meter hits, Timer calls) {
    return () -> calls.getOneMinuteRate() == 0 ? Double.NaN :
                 hits.getOneMinuteRate() / calls.getOneMinuteRate();
}
----
<1> `Metric` _injection_ from the registry
<2> Method _instrumentation_ with CDI interceptors
<3> Produce a custom `Metric` instance by composing others


[.topic.source]
== References

NOTE: Slides generated with _Asciidoctor_, _PlantUML_ and _DZSlides_ backend

NOTE: Original slide template - _Dan Allen_ & _Sarah White_

NOTE: Camel CDI Extension - https://github.com/astefanutti/camel-cdi

NOTE: Metrics CDI Extension - https://github.com/astefanutti/metrics-cdi


[.topic.ending, hrole="name"]
== Antoine Sabot-Durand Antonin Stefanutti

[.footer]
icon:twitter[] @antoine_sd @astefanut
