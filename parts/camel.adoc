[.topic.intro]
== Camel CDI

====
How to use CDI as dependency injection container for an integration framework (Apache Camel)
====


[.topic.source]
== About Apache Camel

NOTE: Open-source _integration framework_ based on known Enterprise Integration Patterns

NOTE: Provides a variety of DSLs to write routing and mediation rules

NOTE: Provides support for _bean binding_ and seamless integration with DI frameworks

image::eip.gif[height="150"]


== !

[.statement]
Discover how did we create CDI integration module for Camel


[.topic.source]
== Camel out of the box (NO CDI)

[source, subs="verbatim,quotes"]
----
class CamelMain {
    static CamelContext camelContext = new DefaultCamelContext();
    static CountDownLatch latch = new CountDownLatch(1);

    public static void main(String[] args) {
        SjmsComponent component = new SjmsComponent();
        component.setConnectionFactory(/\*...*/);
        camelContext.addComponent("sjms", component);
        camelContext.addRoutes(new RouteBuilder() {
            public void configure() {
                from("file:inputDir?delay=1000").to("sjms:queue:outputDest");
            }
        });
        camelContext.start();
        latch.await(); // Shutdown hook
        camelContext.stop();
    }
}
----


[.topic.source]
== Basic CDI integration...

[source, subs="verbatim,quotes"]
----
class JmsComponentFactoryBean {

    @Produces
    @ApplicationScoped
    SjmsComponent sjmsComponent() {
        SjmsComponent component = new SjmsComponent();
        component.setConnectionFactory(/\*...*/);
        return component;
    }
}

class FileToJmsRouteBean extends RouteBuilder {
    @Override
    public void configure() {
        from("file:inputDir?delay=1000").to("sjms:queue:outputDest");
    }
}
----


[.topic.source]
== Basic CDI integration...

[source, subs="verbatim,quotes"]
----
@ApplicationScoped
class CamelContextBean extends DefaultCamelContext {
    @Inject
    CamelContextBean(FileToJmsRouteBean route, SjmsComponent sjmsComponent) {
        addComponent("sjms", sjmsComponent);
        addRoutes(route);
    }
    @PostConstruct
    void postConstruct() {
        super.start();
    }
    @PreDestroy
    void preDestroy() {
        super.stop();
    }
}
----
TIP: We could have a lot more with advanced *CDI* features


[.topic.source]
== Our Goals

. Avoid assembling and configuring the `CamelContext` manually

. Access CDI beans from the Camel DSL

[source, subs="verbatim,quotes"]
----
.to("[highlight]#sjms#:queue:outputDest");
.bean([highlight]#MyBean.class#);
.beanRef([highlight]#"beanName"#);
----

. Support Camel annotations in CDI beans

[source, subs="verbatim,quotes"]
----
[highlight]#@EndpointInject#(uri="jms:queue:foo")
Endpoint endpoint;

[highlight]#@PropertyInject#(value = "timeout", defaultValue = "5000")
int timeout;

[highlight]#@BeanInject#("foo")
FooBean foo;
----


[.topic]
== Steps to integrate Camel and CDI

[.statement]
====
TIP: Create a CDI extension that declares and assembles the `CamelContext` bean

TIP: Bind the `CamelContext` lifecycle to the CDI container events

TIP: Implements the Camel SPI to look up CDI bean references

TIP: Use a custom `InjectionTarget` for CDI beans containing Camel annotations

TIP: Use the Magic
====


[.topic.source]
== The `ProcessAnnotatedType` Event

[source]
.`AnnotatedType<X>`
----
public interface AnnotatedType<X> extends Annotated {
    public Class<X> getJavaClass();
    public Set<AnnotatedConstructor<X>> getConstructors();
    public Set<AnnotatedMethod<? super X>> getMethods();
    public Set<AnnotatedField<? super X>> getFields();
}
----

[source]
.`ProcessAnnotatedType<X>`
----
public interface ProcessAnnotatedType<X> {
    public AnnotatedType<X> getAnnotatedType();
    public void setAnnotatedType(AnnotatedType<X> type);
    public void veto();
}
----


[.topic.source]
== The `ProcessInjectionTarget` Event

[source]
.`InjectionTarget<T>`
----
public interface InjectionTarget<T> extends Producer<T> {
    public void inject(T instance, CreationalContext<T> ctx);
    public void postConstruct(T instance);
    public void preDestroy(T instance);
}
----

[source]
.`ProcessInjectionTarget<T>`
----
public interface ProcessInjectionTarget<X> {
    public AnnotatedType<X> getAnnotatedType();
    public InjectionTarget<X> getInjectionTarget();
    public void setInjectionTarget(InjectionTarget<X> injectionTarget);
    public void addDefinitionError(Throwable t);
}
----


[.topic.source]
== Bean Post Processors

[source, subs="verbatim,quotes"]
----
class CdiCamelExtension implements Extension {
  Set<AnnotatedType<?>> camelBeans = new HashSet<>());

  void camelAnnotations(@Observes [highlight]#@WithAnnotations({BeanInject.class, <1>
      Consume.class, EndpointInject.class, Produce.class, PropertyInject.class})#
      ProcessAnnotatedType<?> pat) {
        camelBeans.add(pat.getAnnotatedType());
  }

  <T> void camelBeansPostProcessor(@Observes [highlight]#ProcessInjectionTarget<T># pit) {
      if (camelBeans.contains(pit.getAnnotatedType())) <2>
        pit.setInjectionTarget(new CamelInjectionTarget<>(pit.getInjectionTarget()));
  }
}
----
<1> Detect all the types containing Camel annotations with `@WithAnnotations`
<2> Decorate the `InjectionTarget` corresponding to these types with a custom post-processor


[.topic.source]
== `InjectionTarget` Decoration

[source, subs="verbatim,quotes"]
----
class CamelInjectionTarget<T> [highlight]#implements InjectionTarget<T># {
    InjectionTarget<T> delegate;

    DefaultCamelBeanPostProcessor processor;

    CamelInjectionTarget(InjectionTarget<T> target) {
        delegate = target;
        processor = new DefaultCamelBeanPostProcessor();
    }
    @Override
    public void [highlight]#inject#(T instance, CreationalContext<T> ctx) {
        delegate.inject(instance, ctx);
        [highlight]#processor.postProcessBeforeInitialization(instance)#; <1>
    }
}
----
<1> Call the Camel default bean post-processor after CDI injection
