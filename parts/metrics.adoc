[.topic.intro]
== 3rd party Library

====
How to integrate a 3rd party Library (Dropwizard Metrics) into the CDI Programming Model
====


[.topic.source]
== About Dropwizard Metrics

[.statement]
====
NOTE: provides different metric types: `Counter`, `Gauge`, `Meter`, `Timer`, ...

NOTE: provides different reporter: JMX, console, SLF4J, CSV, servlet, ...

NOTE: provides a `MetricRegistry` which collects all your app metrics

NOTE: provides annotations for AOP frameworks: `@Counted`, `@Timed`, ...

NOTE: ... but does not include integration with these frameworks

NOTE: more at https://dropwizard.github.io/metrics
====

== !


[.statement]
Discover how did we create CDI integration module for Metrics

[.topic.source]
== Metrics out of the box (NO CDI)
[source, subs="verbatim,quotes"]
----
class MetricsHelper {
    public static MetricRegistry registry = new MetricRegistry();
}
----

[source, subs="verbatim,quotes"]
----
class TimedMethodClass {
    void timedMethod() {
        Timer timer = MetricsHelper.registry.[highlight]#timer("timer")#; <1>
        Timer.Context time = timer.time();
        try { ... }
        finally { time.stop();}
    }
}
----
<1> Note that if "timer" `Timer` doesn't exist, `MetricRegistry` will create a default one and register it

[.topic.source]
== Basic CDI integration...

[source, subs="verbatim,quotes"]
----
class MetricRegistryBean {
    @Produces @ApplicationScoped
    MetricRegistry registry = new MetricRegistry();
}
...
class TimedMethodBean {
    @Inject MetricRegistry registry;
    void timedMethod() {
        Timer timer = registry.timer("timer");
        Timer.Context time = timer.time();
        try { ... } finally { time.stop();}
    }
}
----
TIP: We could have a lot more with advanced *CDI* features

[.topic.source]
== Our Goals

. Apply a metrics with provided annotation in AOP style
+
[source, subs="verbatim,quotes"]
----
@Timed("timer")
void timedMethod() { ... }
----

. Register automatically produced custom metrics
+
[source, subs="verbatim,quotes"]
----
@Produces [highlight]#@Metric#(name="myTimer") <1>
Timer timer = new Timer(new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));
...
@Timer("myTimer")
void timedMethod() { ... }
----
<1> Annotation provided by Metrics

[.topic]
== Steps to apply a metrics in AOP style

[.statement]
====
TIP: Create an interceptor for the timer technical code

TIP: Make the Metrics annotation `@Timed` a valid interceptor binding annotation

TIP: programmatically add `@Timed` as an interceptor binding

TIP: Use the Magic
====

[.topic.source]
== Create an interceptor: detecting the "technical code"

[source, subs="verbatim,quotes"]
----
class TimedMethodBean {
    [highlight]#@Inject MetricRegistry registry;#
    void timedMethod() {
        [highlight]#Timer timer = registry.timer("timer");#
        [highlight]#Timer.Context time = timer.time();#
        try { ... }
        finally { [highlight]#time.stop();#}
    }
}
----
NOTE: it's the code that should be repeated in each method for which we want to use the `Timer`


[.topic.source]
== Creating the interceptor

[source, subs="verbatim,quotes"]
----
[highlight]#@Interceptor#
class TimedInterceptor {
    @Inject MetricRegistry registry; <1>
    [highlight]#@AroundInvoke#
    Object timeMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try { return [highlight]#context.proceed()#;} <5>
        finally { time.stop(); }
    }
}
----
<1> in CDI an interceptor is a bean: you can inject other beans in it
<2> here the "business" of the application is called. All the code around is the technical one

[.topic.source]
== Activating the interceptor

[source, subs="verbatim,quotes"]
----
@Interceptor
[highlight]#@Priority(Interceptor.Priority.LIBRARY_BEFORE)#  <1>
class TimedInterceptor {
    @Inject MetricRegistry registry;
    @AroundInvoke#
    Object timeMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try { return context.proceed();}
        finally { time.stop(); }
    }
}
----
<1> giving a `@Priority` to an interceptor activates it. This annotation is part of the "Common Annotation" specification (JSR 250). In CDI interceptor activation can also be done in `beans.xml` file.


[.topic.source]
== Add a binding to the interceptor

[source, subs="verbatim,quotes"]
----
@Interceptor
[highlight]#@Timed#  <1>
@Priority(Interceptor.Priority.LIBRARY_BEFORE)
class TimedInterceptor {
    @Inject MetricRegistry registry;
    @AroundInvoke#
    Object timeMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try { return context.proceed();}
        finally { time.stop(); }
    }
}
----
<1> We'll use metrics `@Timed` annotation as interceptor binding

[.topic.source]
== Back on interceptor binding
TIP: An interceptor binding is an annotation used in 2 kind of places:

. On the interceptor definitions to associates them to this annotation
. On the Methods / Classes we want to be intercepted by this interceptor


TIP: An interceptor binding should be annotated with the `@InterceptorBinding` meta annotation or should be declared as an interceptor binding programmatically

TIP: If the interceptor binding annotation has members:

. their values are taken into account to distinguish two instances
. unless members are annotated with `@NonBinding`


[.topic.source]
== `@Timed` source code tells us it's not an interceptor binding

[source, subs="verbatim,quotes"]
----
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
<1>
public @interface Timed {
    String name() default ""; <2>
    boolean absolute() default false; <2>
}
----
<1> lack of `@InterceptorBinding` annotation and we have no code to add it programmatically.
<2> none of the members have the `@NonBinding` annotation so they'll be used to distinguish two instances (i.e. `@Timed(name="timer1")` and `@Timed(name="timer2")` will be 2 different interceptor bindings)

[.topic.source]
== The needed `@Timed` to make it an interceptor binding

[source, subs="verbatim,quotes"]
----
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
[highlight]#@InterceptorBinding#
public @interface Timed {
    [highlight]#@NonBinding# String name() default "";
    [highlight]#@NonBinding# boolean absolute() default false;
}
----

* icon:question-circle[] How to transform the existing `@Timed` in the needed version?

[.topic.source]
== Remember the `AnnotatedType` SPI?

TIP: thanks to DeltaSpike we can easily create the required `AnnotatedType`

[source, subs="verbatim,quotes"]
----
AnnotatedType createTimedAnnotatedType() throws Exception {
        Annotation nonBinding = new AnnotationLiteral<Nonbinding>() {}; <1>
        return new AnnotatedTypeBuilder().readFromType(Timed.class) <2>
           .addToMethod(Timed.class.getMethod("name"), nonBinding) <3>
           .addToMethod(Timed.class.getMethod("absolute"), nonBinding) <3>
           .create();
}
----
<1> This creates an instance of `@NonBinding` annotation
<2> It would have been possible but far more verbose to create this AnnotatedType without the help of DeltaSpike. The `AnnotatedTypeBuilder` is initialized with Metrics `Timed` annotation
<3> `@NonBinding` is added to both members of `@Timed` annotation

[.topic.source]
== Add `@Timed` to the list of interceptor binding wit an extension

TIP: by observing `BeforeBeanDiscovery` lifecycle event

[source, subs="verbatim,quotes"]
----
public interface BeforeBeanDiscovery {
  addQualifier(Class<? extends Annotation> qual);
  addQualifier(AnnotatedType<? extends Annotation> qual);
  addScope(Class<? extends Annotation> scp, boolean nm, boolean psv);
  addStereotype(Class<? extends Annotation> strt, Annotation... sd);
  [highlight]#addInterceptorBinding(AnnotatedType<? extends Annotation> type);#  <1>
  addInterceptorBinding(Class<? extends Annotation> type, Annotation... btd);
  addAnnotatedType(AnnotatedType<?> type);
  addAnnotatedType(AnnotatedType<?> type, String id);
}
----
<1> This method is the one we need to use our `@Timed` AnnotatedType


[.topic.source]
== `BeforeBeanDiscovery` is first in Lifecycle

[plantuml, "lifecycle-pat", "svg", height="85%", width="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  FontSize 20
  FontName Consolas
  FontColor #337788
  ArrowColor #888888
  BorderColor #337788
  BackgroundColor #white

  FontColor<< Internal >> #888888
  BorderColor<< Internal >> #888888
  BackgroundColor<< Internal >> #white

  FontColor<< Once >> #BB3322
  BorderColor<< Once >> #BB3322
  BackgroundColor<< Once >> #white

  FontColor<< Highlight >> white
  BorderColor<< Highlight >> #337788
  BackgroundColor<< Highlight >> #337788
}

(*) -right-> "Deployment\nStart" << Internal >>
-right-> "Before\nBean\nDiscovery" <<Highlight>>
-right-> "Scan\nArchive" << Internal >>
-right-> "Process\nAnnotated\nType"
-right-> "After\nType\nDiscovery" << Once >>
-down-> "Bean\nEligibility\nCheck" << Internal >>
-left-> "Process\nInjection\nPoint"
-left-> "Process\nInjection\nTarget"
-left-> "Process\nBean\nAttributes"
-down-> "Process\nBean"
-right-> "Process\nProducer"
-right-> "Process\nObserver\nMethod"
-right-> "After\nBean\nDiscovery" << Once >>
-down-> "After\nDeployment\nValidation" << Once >>
-left-> "Application\nRunning" << Internal >>
-left-> "Before\nShutdown" << Once >>
-left-> "Undeploy\nApplication" << Internal >>
-left-> (*)

@enduml
----

include::legend.adoc[]


[.topic.source]
== This extension will do the job

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {

  void addTimedBinding(@Observes [highlight]#BeforeBeanDiscovery# bbd) {
    bbd.[highlight]#addInterceptorBinding#(createTimedAnnotatedType());
  }

  private AnnotatedType createTimedAnnotatedType() throws Exception {
          Annotation nonBinding = new AnnotationLiteral<Nonbinding>() {};
          return new AnnotatedTypeBuilder().readFromType(Timed.class)
             .addToMethod(Timed.class.getMethod("name"), nonBinding)
             .addToMethod(Timed.class.getMethod("absolute"), nonBinding)
             .create();
  }
}
----


[.topic]
== First Goal achieved

[.statement]
====
TIP: We can now write:

[source, subs="verbatim,quotes"]
----
@Timed("timer")
void timedMethod(){
  //Business code
}
----

And have Metrics Timer applied to the method
====

[.topic.source]
== Metrics Customization

icon:question-circle[] How to customize the metric instances

[source, subs="verbatim,quotes"]
----
@AroundInvoke
Object timedMethod(InvocationContext context) throws Exception {
    String name = context.getMethod().getAnnotation(Timed.class).name();
    [highlight]#Timer timer = registry.timer(name)#; <1>
    Timer.Context time = timer.time();
    try {
        return context.proceed();
    } finally {
        time.stop();
    }
}
----
<1> Default `Timer` histogram is exponentially biased to the past 5 minutes of measurements


[.topic.recap]
== `Timer` Example

[source, subs="verbatim,quotes"]
----
class TimedMethodBean {

    @Inject
    TimedMethodBean(MetricRegistry registry) {
      Timer timer = new Timer(
          new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));

      if (!registry.getMetrics().containsKey("timer"))
          registry.register("timer", timer);
    }

    @Timed("timer")
    void timedMethod() {
    }
}
----


[.topic.recap]
== Further CDI

TIP: Use *producer fields / methods* to declare custom +
metrics

[source, subs="verbatim,quotes"]
----

class TimedMethodBean {

    [highlight]#@Produces#
    static Timer timer() {
        return new Timer(new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));
    }

    @Timed("timer")
    void timedMethod() {
    }
}
----


[.topic.source]
== The `ProcessBean<X>` Events

TIP: Detect the *producer fields* and *methods* to instantiate and register the custom metrics

[source]
----
package javax.enterprise.inject.spi;

public interface ProcessProducerField<T, X> extends ProcessBean<X> {
    public AnnotatedField<T> getAnnotatedProducerField();
    public AnnotatedParameter<T> getAnnotatedDisposedParameter();
    // ProcessBean<X>
    public Annotated getAnnotated();
    public Bean<X> getBean();
}
----

NOTE: `ProcessManagedBean<X>` and `ProcessProducerMethod<T, X>` are fired for managed beans and producer methods respectively


[.topic.source]
== `ProcessBean<X>` in Lifecycle

[plantuml, "lifecycle-pb", "svg", height="85%", width="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  FontSize 20
  FontName Consolas
  FontColor #337788
  ArrowColor #888888
  BorderColor #337788
  BackgroundColor #white

  FontColor<< Internal >> #888888
  BorderColor<< Internal >> #888888
  BackgroundColor<< Internal >> #white

  FontColor<< Once >> #BB3322
  BorderColor<< Once >> #BB3322
  BackgroundColor<< Once >> #white

  FontColor<< Highlight >> white
  BorderColor<< Highlight >> #337788
  BackgroundColor<< Highlight >> #337788
}

(*) -right-> "Deployment\nStart" << Internal >>
-right-> "Before\nBean\nDiscovery" << Once >>
-right-> "Scan\nArchive" << Internal >>
-right-> "Process\nAnnotated\nType"
-right-> "After\nType\nDiscovery" << Once >>
-down-> "Bean\nEligibility\nCheck" << Internal >>
-left-> "Process\nInjection\nPoint"
-left-> "Process\nInjection\nTarget"
-left-> "Process\nBean\nAttributes"
-down-> "Process\nBean" <<Highlight>>
-right-> "Process\nProducer"
-right-> "Process\nObserver\nMethod"
-right-> "After\nBean\nDiscovery" << Once >>
-down-> "After\nDeployment\nValidation" << Once >>
-left-> "Application\nRunning" << Internal >>
-left-> "Before\nShutdown" << Once >>
-left-> "Undeploy\nApplication" << Internal >>
-left-> (*)

@enduml
----

include::legend.adoc[]


[.topic.source]
== The `AfterDeploymentValidation` Event

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {
  Map<Bean<?>, AnnotatedMember<?>> metrics = new HashMap<>();
  void producerFields(@Observes [highlight]#ProcessProducerField<? extends Metric, ?># ppf) {
    metrics.put(ppf.getBean(), ppf.getAnnotatedProducerField()); <1>
  }
  void producerMethods(@Observes [highlight]#ProcessProducerMethod<? extends Metric, ?># ppm) {
    metrics.put(ppm.getBean(), ppm.getAnnotatedProducerMethod()); <1>
  }
  void customMetrics(@Observes [highlight]#AfterDeploymentValidation# adv, BeanManager manager) {
    for (Map.Entry<Bean<?>, AnnotatedMember<?>> metric : metrics.entrySet())
      registry.register(member.getName(), manager.getReference(metric.getKey(), <2>
        metric.getValue().getBaseType(), manager.createCreationalContext(null)));
  }
}
----
<1> Collect the custom `Metric` producer fields and methods
<2> Instantiate and register the custom metrics into the Metrics registry


[.topic.source]
== Example: Composition of Metrics

[source, subs="verbatim,quotes"]
----
@Inject
private Meter [highlight]#hits#; <1>

@Timed(name = "[highlight]#calls#") <2>
public void cachedMethod() {
    if (hit) hits.mark();
}

@Produces @Metric(name = "[highlight]#cache-hits#") <3>
private Gauge<Double> cacheHitRatioGauge(Meter [highlight]#hits#, Timer [highlight]#calls#) {
    return () -> calls.getOneMinuteRate() == 0 ? Double.NaN :
                 hits.getOneMinuteRate() / calls.getOneMinuteRate();
}
----
<1> `Metric` _injection_ from the registry
<2> Method _instrumentation_ with interceptors
<3> Produce a custom `Metric` instance by composing others
