[.topic.intro]
== 3rd party Library

====
How to integrate a 3rd party Library (Dropwizard Metrics) into the CDI Programming Model
====


[.topic.source]
== About Dropwizard Metrics

[.statement]
====
NOTE: provides different metric types: `Counter`, `Gauge`, `Meter`, `Timer`, ...

NOTE: provides different reporter: JMX, console, SLF4J, CSV, servlet, ...

NOTE: provides a `MetricRegistry` which collects all your app metrics

NOTE: provides annotations for AOP frameworks: `@Counted`, `@Timed`, ...

NOTE: ... but does not include integration with these frameworks

NOTE: more at https://dropwizard.github.io/metrics
====

== !


[.statement]
Discover how we created CDI integration module for Metrics

[.topic.source]
== Metrics out of the box (NO CDI)
[source, subs="verbatim,quotes"]
----
class MetricsHelper {
    public static MetricRegistry registry = new MetricRegistry();
}
----

[source, subs="verbatim,quotes"]
----
class TimedMethodClass {
    void timedMethod() {
        Timer timer = MetricsHelper.registry.[highlight]#timer("timer")#; <1>
        Timer.Context time = timer.time();
        try { ... }
        finally { time.stop();}
    }
}
----
<1> Note that if "timer" `Timer` doesn't exist, `MetricRegistry` will create a default one and register it

[.topic.source]
== Basic CDI integration...

[source, subs="verbatim,quotes"]
----
class MetricRegistryBean {
    @Produces @ApplicationScoped
    MetricRegistry registry = new MetricRegistry();
}
...
class TimedMethodBean {
    @Inject MetricRegistry registry;
    void timedMethod() {
        Timer timer = registry.timer("timer");
        Timer.Context time = timer.time();
        try { ... } finally { time.stop();}
    }
}
----
TIP: We could have a lot more with advanced *CDI* features

[.topic.source]
== Our Goals

. Apply a metrics with provided annotation in AOP style
+
[source, subs="verbatim,quotes", role="smallest"]
----
@Timed("timer") <1>
void timedMethod() {
  ...
  }
----

. Register automatically produced custom metrics
+
[source, subs="verbatim,quotes", role="smallest"]
----
@Produces [highlight]#@Metric#(name="myTimer") <1>
Timer timer = new Timer(new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));
...
[highlight]#@Timer#("myTimer") <1>
void timedMethod() { ... }
----
<1> Annotations provided by Metrics

[.topic]
== Steps to apply a timer in AOP style

[.statement]
====
TIP: Create an interceptor for the timer technical code

TIP: Make the Metrics annotation `@Timed` a valid interceptor binding annotation

TIP: programmatically add `@Timed` as an interceptor binding

TIP: Use the Magic
====

[.topic.source]
== Preparing interceptor creation

TIP: to create an interceptor we should start by detecting the "technical code" that will wrap the "business code"

[source, subs="verbatim,quotes"]
----
class TimedMethodBean {
    [highlight]#@Inject MetricRegistry registry;#
    void timedMethod() {
        [highlight]#Timer timer = registry.timer("timer");#
        [highlight]#Timer.Context time = timer.time();#
        [highlight]#try {# //business code [highlight]#}#
        [highlight]#finally { [highlight]#time.stop();}#
    }
}
----


[.topic.source]
== Creating the interceptor
TIP: Interceptor is an independent specification (JSR 318). +
Highlighted code below is part of it.

[source, subs="verbatim,quotes", role="smaller"]
----
[highlight]#@Interceptor#
class TimedInterceptor {
    @Inject MetricRegistry registry; <1>
    [highlight]#@AroundInvoke#
    Object timeMethod([highlight]#InvocationContext# context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try { return [highlight]#context.proceed()#;} <5>
        finally { time.stop(); }
    }
}
----
<1> in CDI an interceptor is a bean: you can inject other beans in it
<2> here the "business" of the application is called. All the code around is the technical one

[.topic.source]
== Activating the interceptor

[source, subs="verbatim,quotes"]
----
@Interceptor
[highlight]#@Priority(Interceptor.Priority.LIBRARY_BEFORE)#  <1>
class TimedInterceptor {
    @Inject MetricRegistry registry;
    @AroundInvoke
    Object timeMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try { return context.proceed();}
        finally { time.stop(); }
    }
}
----
<1> giving a `@Priority` to an interceptor activates it. This annotation is part of the "Common Annotation" specification (JSR 250). In CDI, interceptor activation can also be done in `beans.xml` file.


[.topic.source]
== Add a binding to the interceptor

[source, subs="verbatim,quotes"]
----
@Interceptor
[highlight]#@Timed#  <1>
@Priority(Interceptor.Priority.LIBRARY_BEFORE)
class TimedInterceptor {
    @Inject MetricRegistry registry;
    @AroundInvoke#
    Object timeMethod(InvocationContext context) throws Exception {
        String name = context.getMethod().getAnnotation(Timed.class).name();
        Timer timer = registry.timer(name);
        Timer.Context time = timer.time();
        try { return context.proceed();}
        finally { time.stop(); }
    }
}
----
<1> We'll use metrics `@Timed` annotation as interceptor binding

[.topic.source]
== Back on interceptor binding
TIP: An interceptor binding is an annotation used in 2 kind of places:

. On the interceptor definitions to associates them to this annotation
. On the Methods / Classes we want to be intercepted by this interceptor


TIP: An interceptor binding should be annotated with the `@InterceptorBinding` meta annotation or should be declared as an interceptor binding programmatically

TIP: If the interceptor binding annotation has members:

. their values are taken into account to distinguish two instances
. unless members are annotated with `@NonBinding`


[.topic.source]
== `@Timed` source code tells us it's not an interceptor binding

[source, subs="verbatim,quotes"]
----
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
<1>
public @interface Timed {
    String name() default ""; <2>
    boolean absolute() default false; <2>
}
----
<1> lack of `@InterceptorBinding` annotation and we have no code to add it programmatically.
<2> none of the members have the `@NonBinding` annotation so they'll be used to distinguish two instances (i.e. `@Timed(name="timer1")` and `@Timed(name="timer2")` will be 2 different interceptor bindings)

[.topic.source]
== The needed `@Timed` to make it an interceptor binding

[source, subs="verbatim,quotes"]
----
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
[highlight]#@InterceptorBinding#
public @interface Timed {
    [highlight]#@NonBinding# String name() default "";
    [highlight]#@NonBinding# boolean absolute() default false;
}
----

icon:question-circle[] How to obtain the required `@Timed`?

[.topic.source]
== Remember the `AnnotatedType` SPI?

TIP: thanks to DeltaSpike we can easily create the required `AnnotatedType`

[source, subs="verbatim,quotes"]
----
AnnotatedType createTimedAnnotatedType() throws Exception {
        Annotation nonBinding = new AnnotationLiteral<Nonbinding>() {}; <1>
        return new AnnotatedTypeBuilder().readFromType(Timed.class) <2>
           .addToMethod(Timed.class.getMethod("name"), nonBinding) <3>
           .addToMethod(Timed.class.getMethod("absolute"), nonBinding) <3>
           .create();
}
----
<1> This creates an instance of `@NonBinding` annotation
<2> It would have been possible but far more verbose to create this AnnotatedType without the help of DeltaSpike. The `AnnotatedTypeBuilder` is initialized with Metrics `Timed` annotation
<3> `@NonBinding` is added to both members of `@Timed` annotation

[.topic.source]
== Add `@Timed` to the list of interceptor binding wit an extension

TIP: by observing `BeforeBeanDiscovery` lifecycle event

[source, subs="verbatim,quotes"]
----
public interface BeforeBeanDiscovery {
  addQualifier(Class<? extends Annotation> qual);
  addQualifier(AnnotatedType<? extends Annotation> qual);
  addScope(Class<? extends Annotation> scp, boolean nm, boolean psv);
  addStereotype(Class<? extends Annotation> strt, Annotation... sd);
  [highlight]#addInterceptorBinding(AnnotatedType<? extends Annotation> type);#  <1>
  addInterceptorBinding(Class<? extends Annotation> type, Annotation... btd);
  addAnnotatedType(AnnotatedType<?> type);
  addAnnotatedType(AnnotatedType<?> type, String id);
}
----
<1> This method is the one we need to use our `@Timed` AnnotatedType


[.topic.source]
== `BeforeBeanDiscovery` is first in Lifecycle

[plantuml, "lifecycle-BBD", "svg", height="85%", width="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  FontSize 20
  FontName Consolas
  FontColor #337788
  ArrowColor #888888
  BorderColor #337788
  BackgroundColor #white

  FontColor<< Internal >> #888888
  BorderColor<< Internal >> #888888
  BackgroundColor<< Internal >> #white

  FontColor<< Once >> #BB3322
  BorderColor<< Once >> #BB3322
  BackgroundColor<< Once >> #white

  FontColor<< Highlight >> white
  BorderColor<< Highlight >> #337788
  BackgroundColor<< Highlight >> #337788

  FontColor<< Highlightonce >> white
  BorderColor<< Highlightonce >> #BB3322
  BackgroundColor<< Highlightonce >> #BB3322
}

(*) -right-> "Deployment\nStart" << Internal >>
-right-> "Before\nBean\nDiscovery" <<Highlightonce>>
-right-> "Scan\nArchive" << Internal >>
-right-> "Process\nAnnotated\nType"
-right-> "After\nType\nDiscovery" << Once >>
-down-> "Bean\nEligibility\nCheck" << Internal >>
-left-> "Process\nInjection\nPoint"
-left-> "Process\nInjection\nTarget"
-left-> "Process\nBean\nAttributes"
-down-> "Process\nBean"
-right-> "Process\nProducer"
-right-> "Process\nObserver\nMethod"
-right-> "After\nBean\nDiscovery" << Once >>
-down-> "After\nDeployment\nValidation" << Once >>
-left-> "Application\nRunning" << Internal >>
-left-> "Before\nShutdown" << Once >>
-left-> "Undeploy\nApplication" << Internal >>
-left-> (*)

@enduml
----

include::legend.adoc[]


[.topic.source]
== This extension will do the job

[source, subs="verbatim,quotes"]
----
class MetricsExtension implements Extension {

    void addTimedBinding(@Observes BeforeBeanDiscovery bbd) throws Exception {
        bbd.addInterceptorBinding(createTimedAnnotatedType());
    }

    private AnnotatedType createTimedAnnotatedType() throws Exception {
        Annotation nonBinding = new AnnotationLiteral<Nonbinding>() {};
        return new AnnotatedTypeBuilder().readFromType(Timed.class)
                .addToMethod(Timed.class.getMethod("name"), nonBinding)
                .addToMethod(Timed.class.getMethod("absolute"), nonBinding)
                .create();
    }

}
----


[.topic]
== First Goal achieved

[.statement]
====
TIP: We can now write:

[source, subs="verbatim,quotes"]
----
@Timed("timer")
void timedMethod(){
  //Business code
}
----

And have Metrics Timer applied to the method
====

[.topic.source]
== Second goal: Register automatically produced custom metrics

icon:question-circle[] Why would we want custom metrics?

[source, subs="verbatim,quotes"]
----
@AroundInvoke
Object timedMethod(InvocationContext context) throws Exception {
    String name = context.getMethod().getAnnotation(Timed.class).name();
    [highlight]#Timer timer = registry.timer(name)#; <1>
    Timer.Context time = timer.time();
    try {
        return context.proceed();
    } finally { time.stop();}
}
----
<1> The registry provide a Default `Timer` (if none was registered by the user). The default time histogram is exponentially biased to the past 5 minutes of measurements. We may want to have an other behaviour.

[.topic.source]
== Register automatically produced custom metrics

TIP: We want to write this:

[source, subs="verbatim,quotes"]
----
@Produces [highlight]#@Metric#(name="myTimer")
Timer timer = new Timer(new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));
----
TIP: and have:

. the possibility to retrieved this metric from the registry when it's injected (instead of having a new instance created)
. this `Metric` produced when needed (first use)
. this `Metric` registered in the registry with its name (here "myTimer")

WARNING: There are 2 `Metric`: the `com.codahale.metrics.Metric` interface and the `com.codahale.metrics.annotation.Metric` annotation.

[.topic.source]
== How to achieve this?

TIP: we need to write an extension that will:

. declare `@Metric` as a new Qualifier to ease injection and name resolution in a `BeforeBeanDiscovery` observer
. change how a Metric instance will be produced to look for it in the registry and produce (and register) it only if it's not found. We'll do this by:
.. observing the `ProcessProducer` lifecycle event
.. decorating Metric `Producer` to add this new behaviour.
. Produce all `Metric` at the end of boot time to have them in registry for runtime.
.. we'll do this by observing `AfterDeploymentValidation` event

[.topic.source]
== So we will `@Observes` these 3 events to add our features

[plantuml, "lifecycle-BBD-PP-ADV", "svg", height="85%", width="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  FontSize 20
  FontName Consolas
  FontColor #337788
  ArrowColor #888888
  BorderColor #337788
  BackgroundColor #white

  FontColor<< Internal >> #888888
  BorderColor<< Internal >> #888888
  BackgroundColor<< Internal >> #white

  FontColor<< Once >> #BB3322
  BorderColor<< Once >> #BB3322
  BackgroundColor<< Once >> #white

  FontColor<< Highlight >> white
  BorderColor<< Highlight >> #337788
  BackgroundColor<< Highlight >> #337788

  FontColor<< Highlightonce >> white
  BorderColor<< Highlightonce >> #BB3322
  BackgroundColor<< Highlightonce >> #BB3322
}

(*) -right-> "Deployment\nStart" << Internal >>
-right-> "Before\nBean\nDiscovery" <<Highlightonce>>
-right-> "Scan\nArchive" << Internal >>
-right-> "Process\nAnnotated\nType"
-right-> "After\nType\nDiscovery" << Once >>
-down-> "Bean\nEligibility\nCheck" << Internal >>
-left-> "Process\nInjection\nPoint"
-left-> "Process\nInjection\nTarget"
-left-> "Process\nBean\nAttributes"
-down-> "Process\nBean"
-right-> "Process\nProducer" <<Highlight>>
-right-> "Process\nObserver\nMethod"
-right-> "After\nBean\nDiscovery" << Once >>
-down-> "After\nDeployment\nValidation" <<Highlightonce>>
-left-> "Application\nRunning" << Internal >>
-left-> "Before\nShutdown" << Once >>
-left-> "Undeploy\nApplication" << Internal >>
-left-> (*)

@enduml
----

include::legend.adoc[]


[.topic.source]
== Adding `@Metric` to the list of qualifiers

NOTE: this time we need annotation members to be binding (`@Metric("a")` and `@Metric("b")` should be distinguished)

NOTE: so we don't have to add `@Nonbinding` annotation on them.

[source, subs="verbatim,quotes"]
----
public class MetricExtension implements Extension {

    void addMetricQualifier(@Observes BeforeBeanDiscovery bbd) {
        bbd.addQualifier(Metric.class);
    }
    ...
}
----

[.topic.source]
== Customizing `Metric` producing process

NOTE: We first need to create our implementation of `Producer<T>` SPI

[source, subs="verbatim,quotes", role="smallest"]
----
public class MetricProducer implements Producer<com.codahale.metrics.Metric> {

        private Producer<com.codahale.metrics.Metric> decorated;
        private BeanManager bm;
        private String name;

        public MetricProducer(Producer<com.codahale.metrics.Metric> decorated, String name, BeanManager bm) {
            this.decorated = decorated;
            this.bm = bm;
            this.name = name;
        }

        MetricRegistry getRegistry() {
            return BeanProvider.getContextualReference(bm, MetricRegistry.class, false); <1>
        }
...
----
<1> `BeanProvider` is a Delta Spike helper class to easily retrieve a bean or bean instance



[.topic.source]
== Customizing `Metric` producing process (continued)

[source, subs="verbatim,quotes", role="smallest"]
----
...
        @Override
        public com.codahale.metrics.Metric produce(CreationalContext<com.codahale.metrics.Metric> ctx) {
            MetricRegistry reg = getRegistry();
            if (!reg.getMetrics().containsKey(name))
                reg.register(name, decorated.produce(ctx));
            return reg.getMetrics().get(name);
        }

        @Override
        public void dispose(com.codahale.metrics.Metric instance) { } <1>

        @Override
        public Set<InjectionPoint> getInjectionPoints() {
            return decorated.getInjectionPoints();
        }
    }
----
<1> we don't want to have the produced Metric destroyed by CDI container

[.topic.source]
== We'll use our `Producer<Metric>` in a `ProcessProducer` observer

NOTE: thru this event we can substitute the standard producer by ours

[source, subs="verbatim,quotes"]
----
public interface ProcessProducer<T, X> {
    public AnnotatedMember<T> getAnnotatedMember(); <1>

    public Producer<X> getProducer(); <2>

    public void setProducer(Producer<X> producer); <3>

    public void addDefinitionError(Throwable t);
}
----
<1> used to retrieve annotations associated to `@Produces`
<2> get the default producer (useful to decorate it)
<3> change the producer by ours

[.topic.source]
== Customizing `Metric` producing process (end)

TIP: here's the extension code to do this producer decoration

[source, subs="verbatim,quotes"]
----
public class MetricExtension implements Extension {
...
    void reproduceMetric(@Observes ProcessProducer<?, com.codahale.metrics.Metric> pp,
                          BeanManager bm) {
        String name = pp.getAnnotatedMember().getAnnotation(Metric.class).name();
        pp.setProducer(new [highlight]#MetricProducer#(pp.getProducer(),name,bm));
    }
...
}
----

[.topic.source]
== Producing all the `Metric` at the end of boot time

NOTE: We do that by observing `AfterDeploymentValidation` event

[source, subs="verbatim,quotes", role="smallest"]
----
public class MetricExtension implements Extension {
...
    void regMetrics(@Observes AfterDeploymentValidation adv, BeanManager bm) {
        Set<Bean<?>> metricBeans = bm.getBeans(com.codahale.metrics.Metric.class, new AnyLiteral()); <1>
        for (Bean<?> bean : metricBeans) {
            Metric qual = AnnotationUtils.findAnnotation(bm,(Annotation[])(bean.getQualifiers().toArray()),Metric.class);
            String name = qual.name(); <2>
            BeanProvider.getContextualReference(bm, com.codahale.metrics.Metric.class,false,qual); <3>
        }
...
}
----
<1> getting all the `Metric` beans
<2> retrieving its name in Bean qualifiers
<3> requesting an instance that will use our custom producer and thus will fill the registry

[.topic]
== Second Goal achieved

[.statement]
====
TIP: We can now write:

[source, subs="verbatim,quotes"]
----
@Produces @Metric(name="myTimer")
Timer timer = new Timer(new SlidingTimeWindowReservoir(1L, TimeUnit.MINUTES));
...
@Inject
MetricRegistry registry;

@Inject @Metric("myTimer")
Metric timer;
----

TIP: and be sure that `registry.getMetrics.get("myTimer")` and `timer` are the same object (our custom `Timer`)

====



[.topic.source]
== Complete extension code

[source, subs="verbatim,quotes", role="smallest"]
----
public class MetricExtension implements Extension {
    void reproduceMetric(@Observes ProcessProducer<?, com.codahale.metrics.Metric> pp, BeanManager bm) {
        String name = pp.getAnnotatedMember().getAnnotation(Metric.class).name();
        pp.setProducer(new MetricProducer(pp.getProducer(),name,bm));
    }
    void addTimedBinding(@Observes BeforeBeanDiscovery bbd) throws Exception {
        bbd.addInterceptorBinding(createTimedAnnotatedType());
    }
    private AnnotatedType createTimedAnnotatedType() throws Exception {
        Annotation nonBinding = new AnnotationLiteral<Nonbinding>() {};
        return new AnnotatedTypeBuilder().readFromType(Timed.class)
                .addToMethod(Timed.class.getMethod("name"), nonBinding)
                .addToMethod(Timed.class.getMethod("absolute"), nonBinding).create();
    }
    void addMetricQualifier(@Observes BeforeBeanDiscovery bbd) { bbd.addQualifier(Metric.class); }
    void regMetrics(@Observes AfterDeploymentValidation adv, BeanManager bm) {
        Set<Bean<?>> metricBeans = bm.getBeans(com.codahale.metrics.Metric.class, new AnyLiteral());
        for (Bean<?> bean : metricBeans) {
            Metric qual = AnnotationUtils.findAnnotation(bm,(Annotation[])(bean.getQualifiers().toArray()),Metric.class);
            String name = qual.name();
            BeanProvider.getContextualReference(bm, com.codahale.metrics.Metric.class,false,qual);
        }
    }
}
----
